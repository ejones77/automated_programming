// I provided the skeleton of the main function and used Github Copilot to assist with completion
// Copilot clearly knows about the old version of the code. So it's helpful to know that it can pull from other files in your repo.
// The comment generation is also really neat too
// Copilot code starts below

// Copilot generated code
// This code is generated by GitHub Copilot
// This code is a simple implementation of the Anscombe's quartet
// The Anscombe's quartet is a set of four datasets that have nearly identical simple descriptive statistics, yet have very different distributions and appear very different when graphed. Each dataset consists of eleven (x, y) points. They were constructed in 1973 by the statistician Francis Anscombe to demonstrate both the importance of graphing data before analyzing it and the effect of outliers on statistical properties.
// The code below calculates the linear regression summary statistics for each of the four datasets

package main

import (
	"fmt"
	"math"
	"time"
)

type SummaryStats struct {
	Intercept              float64
	Slope                  float64
	CorrelationCoefficient float64
	RSquared               float64
	StandardError          float64
}

// given a slice of x values and a slice of y values, calculate each metric from the summary stats struct
// returns: SummaryStats
func LmSummary(x, y []float64) SummaryStats {
	n := len(x)
	mean_X := 0.0
	mean_Y := 0.0
	for i := 0; i < n; i++ {
		mean_X += x[i]
		mean_Y += y[i]
	}
	mean_X /= float64(n)
	mean_Y /= float64(n)

	diff_XY := 0.0
	diff_XX := 0.0
	diff_YY := 0.0
	for i := 0; i < n; i++ {
		diff_X := x[i] - mean_X
		diff_Y := y[i] - mean_Y
		diff_XY += diff_X * diff_Y
		diff_XX += diff_X * diff_X
		diff_YY += diff_Y * diff_Y
	}

	slope := diff_XY / diff_XX
	intercept := mean_Y - slope*mean_X

	r := diff_XY / math.Sqrt(diff_XX*diff_YY)
	rSq := r * r

	squared_residuals := 0.0
	for i := 0; i < n; i++ {
		yi := slope*x[i] + intercept
		residual := y[i] - yi
		squared_residuals += residual * residual
	}
	standard_error := math.Sqrt(squared_residuals / float64(n-2))

	return SummaryStats{
		Intercept:              intercept,
		Slope:                  slope,
		CorrelationCoefficient: r,
		RSquared:               rSq,
		StandardError:          standard_error,
	}
}

func copilot_main() {
	start_time := time.Now()
	// the slice of slices makes iterating through each anscombe quadrant easier
	x := [][]float64{
		{10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5},
		{10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5},
		{10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5},
		{8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8},
	}

	y := [][]float64{
		{8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68},
		{8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68},
		{7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73},
		{6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.5, 5.56, 7.91, 6.89},
	}

	for i := range x {
		fmt.Printf("Quadrant %d\n", i+1)
		stats := LmSummary(x[i], y[i])
		fmt.Printf("Intercept: %v\n", stats.Intercept)
		fmt.Printf("Slope: %v\n", stats.Slope)
		fmt.Printf("Correlation Coefficient: %v\n", stats.CorrelationCoefficient)
		fmt.Printf("RSquared Value: %v\n", stats.RSquared)
		fmt.Printf("Standard Error of Estimate: %v\n", stats.StandardError)
		fmt.Println("----------------------------------------------------")
	}
	elapsed := time.Since(start_time)
	fmt.Printf("Took: %s", elapsed)

}
